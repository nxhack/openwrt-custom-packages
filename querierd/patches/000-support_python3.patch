diff -urN a/querier/__init__.py b/querier/__init__.py
--- a/querier/__init__.py	2017-06-27 10:38:07.000000000 +0900
+++ b/querier/__init__.py	2019-12-06 12:56:52.786820466 +0900
@@ -26,6 +26,8 @@
 all_routers = '224.0.0.1'
 mdns_group = '224.0.0.251'
 
+dummy_payload = '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
+
 class Querier:
     """
     Sends an IGMP query packet at a specified time interval (in seconds).
@@ -50,7 +52,7 @@
         def sigterm_handler(signal, frame):
             self.stop = True
         signal.signal(signal.SIGTERM, sigterm_handler)
-        
+
     def build_query_packet(self):
         igmp = IGMPv2Packet()
         igmp.type = 'query'
@@ -63,14 +65,23 @@
         ip.src = self.source_address
         ip.dst = all_routers
         ip.data = igmp
-    
+
     def run(self):
         syslog.syslog('Querier starting.')
         self.listener = QueryListener(self.source_address)
+        str1 = str(self.packet) + dummy_payload
+        mesg = str1.encode('latin_1').decode('unicode-escape').encode('latin_1')
         while True:
             elapsed = self.listener.elapsed()
             if self.elected:
-                self.socket.sendto(str(self.packet), (all_routers, 0))
+                try:
+                    self.socket.sendto(mesg, (all_routers, 0))
+                except OSError as err:
+                    syslog.syslog('socket error: {0}\n'.format(err))
+                    break
+                except socket.error as msg:
+                    syslog.syslog(msg)
+                    break
                 if elapsed < self.interval:
                     self.elected = False
                     syslog.syslog('Lost querier election. Pausing.')
@@ -108,16 +119,16 @@
 
     def _ip_as_int(self, address):
         return struct.unpack("!I", socket.inet_aton(address))[0]
-        
+
     def listen(self):
         while True:
             data, address = self.socket.recvfrom(65565)
-            if ord(data[20]) == 17: # make sure we got a query packet
+            if data[20] == 17: # make sure we got a query packet
                 if self._ip_as_int(address[0]) < self.address:
                     self.lock.acquire()
                     self._timestamp = time.time()
                     self.lock.release()
-    
+
     def elapsed(self):
         """
         Return the time elapsed since receiving a query from a
diff -urN a/querier/daemon.py b/querier/daemon.py
--- a/querier/daemon.py	2017-06-27 10:38:07.000000000 +0900
+++ b/querier/daemon.py	2019-12-06 12:46:09.933105210 +0900
@@ -22,8 +22,8 @@
 # along with QuerierD.  If not, see <http://www.gnu.org/licenses/>.
 
 import sys, os, time, atexit, netifaces
-from signal import SIGTERM 
-from ConfigParser import ConfigParser
+from signal import SIGTERM
+from configparser import ConfigParser
 from . import Querier
 
 config_file = '/etc/querierd'
@@ -44,55 +44,54 @@
         self.source_address = source_address
         self.pidfile = pidfile
         self.stdin, self.stdout, self.stderr = stdin, stdout, stderr
-    
+
     def daemonize(self):
         """
-        Do the UNIX double-fork magic, see Stevens' "Advanced 
+        Do the UNIX double-fork magic, see Stevens' "Advanced
         Programming in the UNIX Environment" for details
         (ISBN 0201563177)
         http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
         """
-        try: 
-            pid = os.fork() 
+        try:
+            pid = os.fork()
             if pid > 0:
                 # exit first parent
-                sys.exit(0) 
-        except OSError, e: 
-            sys.stderr.write("fork #1 failed: %d (%s)\n" %
-                             (e.errno, e.strerror))
+                sys.exit(0)
+        except OSError as err:
+            sys.stderr.write('fork #1 failed: {0}\n'.format(err))
             sys.exit(1)
-    
+
         # decouple from parent environment
-        os.chdir("/") 
-        os.setsid() 
-        os.umask(0) 
-    
+        os.chdir("/")
+        os.setsid()
+        os.umask(0)
+
         # do second fork
-        try: 
-            pid = os.fork() 
+        try:
+            pid = os.fork()
             if pid > 0:
                 # exit from second parent
-                sys.exit(0) 
-        except OSError, e: 
-            sys.stderr.write("fork #2 failed: %d (%s)\n" %
-                             (e.errno, e.strerror))
-            sys.exit(1) 
-    
+                sys.exit(0)
+        except OSError as err:
+            sys.stderr.write('fork #2 failed: {0}\n'.format(err))
+            sys.exit(1)
+
         # redirect standard file descriptors
         sys.stdout.flush()
         sys.stderr.flush()
-        si = file(self.stdin, 'r')
-        so = file(self.stdout, 'a+')
-        se = file(self.stderr, 'a+', 0)
+        si = open(self.stdin, 'r')
+        so = open(self.stdout, 'a+')
+        se = open(self.stderr, 'a+')
         os.dup2(si.fileno(), sys.stdin.fileno())
         os.dup2(so.fileno(), sys.stdout.fileno())
         os.dup2(se.fileno(), sys.stderr.fileno())
-    
+
         # write pidfile
         atexit.register(self.delpid)
         pid = str(os.getpid())
-        file(self.pidfile,'w+').write("%s\n" % pid)
-    
+        with open(self.pidfile,'w+') as f:
+          f.write(pid + '\n')
+
     def delpid(self):
         os.remove(self.pidfile)
 
@@ -102,52 +101,50 @@
         """
         # Check for a pidfile to see if the daemon is already running
         try:
-            pf = file(self.pidfile,'r')
-            pid = int(pf.read().strip())
-            pf.close()
+            with open(self.pidfile,'r') as pf:
+              pid = int(pf.read().strip())
         except IOError:
             pid = None
-    
+
         if pid:
             message = ("The file %s exists.\n"
                        "Is querierd already running?\n")
             sys.stderr.write(message % self.pidfile)
             sys.exit(1)
-        
+
         # Start the daemon
         self.daemonize()
         self.run()
-        
+
     def stop(self):
         """
         Stop the daemon
         """
         # Get the pid from the pidfile
         try:
-            pf = file(self.pidfile,'r')
-            pid = int(pf.read().strip())
-            pf.close()
+            with open(self.pidfile,'r') as pf:
+              pid = int(pf.read().strip())
         except IOError:
             pid = None
-    
+
         if not pid:
             message = ("The pidfile %s does not exist."
                        "Was the querierd already stopped?\n")
             sys.stderr.write(message % self.pidfile)
             return # not an error in a restart
 
-        # Try killing the daemon process    
+        # Try killing the daemon process
         try:
             while 1:
                 os.kill(pid, SIGTERM)
                 time.sleep(0.1)
-        except OSError, err:
-            err = str(err)
-            if err.find("No such process") > 0:
+        except OSError as err:
+            e = str(err.args)
+            if e.find("No such process") > 0:
                 if os.path.exists(self.pidfile):
                     os.remove(self.pidfile)
             else:
-                print str(err)
+                print(str(err.args))
                 sys.exit(1)
 
     def restart(self):
@@ -161,14 +158,14 @@
         """
         Create a Querier and let it run.
         """
-        print 'querier service starting. Using address %s'%ip
+        print('querier service starting. Using address %s'%ip)
         Querier(self.source_address, self.interval).run()
 
 if __name__ == "__main__":
     if os.getuid() != 0:
-        print 'The querierd daemon must be controlled by root.'
+        print('The querierd daemon must be controlled by root.')
         sys.exit(1)
-                
+
     config = ConfigParser()
     config.read(config_file)
     pidfile = config.get('querierd', 'pidfile')
@@ -181,21 +178,20 @@
             'Interface %s not found. Please check %s .'%(interface, config_file)
         )
     daemon = QuerierDaemon(query_interval, ip, pidfile)
-    
+
     if len(sys.argv) == 2:
         if 'start' == sys.argv[1]:
-            print 'Querier daemon starting at %s.'%ip
+            print('Querier daemon starting at %s.'%ip)
             daemon.start()
         elif 'stop' == sys.argv[1]:
-            print 'querierd stopping.'
+            print('querierd stopping.')
             daemon.stop()
         elif 'restart' == sys.argv[1]:
             daemon.restart()
         else:
-            print "Unknown command"
+            print("Unknown command")
             sys.exit(2)
         sys.exit(0)
     else:
-        print "usage: %s start|stop|restart" % sys.argv[0]
+        print("usage: %s start|stop|restart" % sys.argv[0])
         sys.exit(2)
-
diff -urN a/querier/packets.py b/querier/packets.py
--- a/querier/packets.py	2017-06-27 10:38:07.000000000 +0900
+++ b/querier/packets.py	2019-12-06 12:36:00.574498476 +0900
@@ -51,7 +51,7 @@
 
     def header(self):
         values = [getattr(self, field) for field in self.fields]
-        return struct.pack(self.format, *values)
+        return str(struct.pack(self.format, *values))[2:-1]
 
     def compute_checksum(self):
         self.checksum = 0
@@ -70,7 +70,7 @@
     def data(self, data):
         self._data = str(data)
         self.length = LENGTH(self.hdr_length + len(self._data))
-        
+
 class IGMPv2Packet(Packet):
     fields = ['_type', '_max_response_time', 'checksum', '_group']
     formats = {'_type':'B', '_max_response_time':'B', 'checksum':'H',
@@ -100,7 +100,7 @@
         return self._dst
     @group.setter
     def group(self, addr):
-        self._group = struct.unpack("!I", socket.inet_aton(addr))[0]  
+        self._group = struct.unpack("!I", socket.inet_aton(addr))[0]
 
 class IPv4Packet(Packet):
     fields = ['version_ihl', 'tos', 'length', '_id',
@@ -114,7 +114,7 @@
     _id = 0
     flags_offset = 0
     _ttl = 64
-    _protocol = 0 
+    _protocol = 0
     checksum = 0
     _src = 0
     _dst = 0
@@ -145,11 +145,11 @@
         return self._src
     @protocol.setter
     def src(self, addr):
-        self._src = struct.unpack("!I", socket.inet_aton(addr))[0]  
+        self._src = struct.unpack("!I", socket.inet_aton(addr))[0]
 
     @property
     def dst(self):
         return self._dst
     @protocol.setter
     def dst(self, addr):
-        self._dst = struct.unpack("!I", socket.inet_aton(addr))[0]  
+        self._dst = struct.unpack("!I", socket.inet_aton(addr))[0]
diff -urN a/querier/service.py b/querier/service.py
--- a/querier/service.py	2017-06-27 10:38:07.000000000 +0900
+++ b/querier/service.py	2019-12-02 14:12:48.790684848 +0900
@@ -18,14 +18,14 @@
 # along with QuerierD.  If not, see <http://www.gnu.org/licenses/>.
 
 import os, netifaces
-from ConfigParser import ConfigParser
+from configparser import ConfigParser
 from . import Querier
 
 config_file = '/etc/querierd'
 
 def main():
     if os.getuid() != 0:
-        print 'You must be root to run a querier.'
+        print('You must be root to run a querier.')
         sys.exit(1)
 
     config = ConfigParser()
@@ -38,9 +38,8 @@
         raise ValueError(
             'Interface %s not found. Please check %s .'%(interface, config_file)
         )
-    print 'querier service starting. Using address %s'%ip
+    print('querier service starting. Using address %s'%ip)
     Querier(ip, query_interval).run()
 
 if __name__ == "__main__":
     main()
-
